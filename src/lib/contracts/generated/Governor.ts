/* Generated by ts-generator ver. 0.0.8 */
/* tslint:disable */

import BN from "bn.js";
import Web3 from "web3";
import { PromiEvent, TransactionReceipt } from "web3-core/types";

import { Abi } from "./Governor.abi";
import { Governor as Web3Contract } from "./Governor.web3";
import { PayableTransactionObject, NonPayableTransactionObject } from "./types";

interface IParams {
  address: string;
  web3: Web3;
  sender?: string; // the address of sender, if undefined then web3.eth.defaultAccount used
  gasEstimationMultiplayer?: number; // if undefined then 1
}

const DEFAULT_GAS_ESTIMATION_MULTIPLAYER = 1.1; // + 10 %

export class Governor {
  native: Web3Contract;
  gasEstimationMultiplayer: number;
  web3: Web3;
  _sender: string | undefined;

  get sender(): string | undefined {
    if (this._sender) return this._sender;
    if (this.web3.defaultAccount) return this.web3.defaultAccount;
    return undefined;
  }

  protected getSenderOrFail(): string {
    const sender = this.sender;
    if (!sender) {
      throw new Error("Sender is required");
    }
    return sender;
  }

  constructor({ address, web3, sender, gasEstimationMultiplayer }: IParams) {
    this._sender = sender;
    this.native = new web3.eth.Contract(Abi, address) as any;
    this.gasEstimationMultiplayer =
      gasEstimationMultiplayer ?? DEFAULT_GAS_ESTIMATION_MULTIPLAYER;
    this.web3 = web3;
  }

  protected async estimateGas<
    K,
    T extends PayableTransactionObject<K> | NonPayableTransactionObject<K>
  >(method: T, args?: Parameters<T["estimateGas"]>) {
    const originalEstimation = await method.estimateGas(...(args ?? []));
    return new BN(originalEstimation)
      .muln(this.gasEstimationMultiplayer)
      .toString();
  }

  async BALLOT_TYPEHASH(): Promise<string> {
    return this.native.methods.BALLOT_TYPEHASH().call();
  }

  async DOMAIN_TYPEHASH(): Promise<string> {
    return this.native.methods.DOMAIN_TYPEHASH().call();
  }

  async MAX_PROPOSAL_THRESHOLD(): Promise<string> {
    return this.native.methods.MAX_PROPOSAL_THRESHOLD().call();
  }

  async MAX_VOTING_DELAY(): Promise<string> {
    return this.native.methods.MAX_VOTING_DELAY().call();
  }

  async MAX_VOTING_PERIOD(): Promise<string> {
    return this.native.methods.MAX_VOTING_PERIOD().call();
  }

  async MIN_PROPOSAL_THRESHOLD(): Promise<string> {
    return this.native.methods.MIN_PROPOSAL_THRESHOLD().call();
  }

  async MIN_VOTING_DELAY(): Promise<string> {
    return this.native.methods.MIN_VOTING_DELAY().call();
  }

  async MIN_VOTING_PERIOD(): Promise<string> {
    return this.native.methods.MIN_VOTING_PERIOD().call();
  }

  async admin(): Promise<string> {
    return this.native.methods.admin().call();
  }

  async detf(): Promise<string> {
    return this.native.methods.detf().call();
  }

  async implementation(): Promise<string> {
    return this.native.methods.implementation().call();
  }

  async initialProposalId(): Promise<string> {
    return this.native.methods.initialProposalId().call();
  }

  async isInitiate(): Promise<boolean> {
    return this.native.methods.isInitiate().call();
  }

  async latestProposalIds(arg0: string): Promise<string> {
    return this.native.methods.latestProposalIds(arg0).call();
  }

  async name(): Promise<string> {
    return this.native.methods.name().call();
  }

  async pendingAdmin(): Promise<string> {
    return this.native.methods.pendingAdmin().call();
  }

  async proposalCount(): Promise<string> {
    return this.native.methods.proposalCount().call();
  }

  async proposalMaxOperations(): Promise<string> {
    return this.native.methods.proposalMaxOperations().call();
  }

  async proposalThreshold(): Promise<string> {
    return this.native.methods.proposalThreshold().call();
  }

  async proposals(
    arg0: number | string | BN
  ): Promise<{
    id: string;
    proposer: string;
    eta: string;
    startBlock: string;
    endBlock: string;
    forVotes: string;
    againstVotes: string;
    abstainVotes: string;
    canceled: boolean;
    executed: boolean;
    0: string;
    1: string;
    2: string;
    3: string;
    4: string;
    5: string;
    6: string;
    7: string;
    8: boolean;
    9: boolean;
  }> {
    return this.native.methods.proposals(arg0).call();
  }

  async quorumVotes(): Promise<string> {
    return this.native.methods.quorumVotes().call();
  }

  async timelock(): Promise<string> {
    return this.native.methods.timelock().call();
  }

  async votingDelay(): Promise<string> {
    return this.native.methods.votingDelay().call();
  }

  async votingPeriod(): Promise<string> {
    return this.native.methods.votingPeriod().call();
  }

  async initialize(
    timelock_: string,
    detf_: string,
    votingPeriod_: number | string | BN,
    votingDelay_: number | string | BN,
    proposalThreshold_: number | string | BN
  ): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.initialize(
      timelock_,
      detf_,
      votingPeriod_,
      votingDelay_,
      proposalThreshold_
    );
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async initiate(): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.initiate();
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async castVoteWithReason(
    proposalId: number | string | BN,
    support: number | string | BN,
    reason: string
  ): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.castVoteWithReason(
      proposalId,
      support,
      reason
    );
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async castVoteBySig(
    proposalId: number | string | BN,
    support: number | string | BN,
    v: number | string | BN,
    r: string | number[],
    s: string | number[]
  ): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.castVoteBySig(
      proposalId,
      support,
      v,
      r,
      s
    );
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async setVotingDelay(
    newVotingDelay: number | string | BN
  ): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.setVotingDelay(newVotingDelay);
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async setVotingPeriod(
    newVotingPeriod: number | string | BN
  ): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.setVotingPeriod(newVotingPeriod);
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async setProposalThreshold(
    newProposalThreshold: number | string | BN
  ): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.setProposalThreshold(
      newProposalThreshold
    );
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async setPendingAdmin(
    newPendingAdmin: string
  ): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.setPendingAdmin(newPendingAdmin);
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async acceptAdmin(): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.acceptAdmin();
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async getActions(
    proposalId: number | string | BN
  ): Promise<{
    targets: string[];
    values: string[];
    signatures: string[];
    calldatas: string[];
    0: string[];
    1: string[];
    2: string[];
    3: string[];
  }> {
    return this.native.methods.getActions(proposalId).call();
  }

  async getReceipt(
    proposalId: number | string | BN,
    voter: string
  ): Promise<[boolean, string, string]> {
    return this.native.methods.getReceipt(proposalId, voter).call();
  }

  async state(proposalId: number | string | BN): Promise<string> {
    return this.native.methods.state(proposalId).call();
  }
}
