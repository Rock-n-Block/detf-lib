/* Generated by ts-generator ver. 0.0.8 */
/* tslint:disable */

import BN from "bn.js";
import Web3 from "web3";
import { PromiEvent, TransactionReceipt } from "web3-core/types";

import { Abi } from "./DetfReflect.abi";
import { DetfReflect as Web3Contract } from "./DetfReflect.web3";
import { PayableTransactionObject, NonPayableTransactionObject } from "./types";

interface IParams {
  address: string;
  web3: Web3;
  sender?: string; // the address of sender, if undefined then web3.eth.defaultAccount used
  gasEstimationMultiplayer?: number; // if undefined then 1
}

const DEFAULT_GAS_ESTIMATION_MULTIPLAYER = 1.1; // + 10 %

export class DetfReflect {
  native: Web3Contract;
  gasEstimationMultiplayer: number;
  web3: Web3;
  _sender: string | undefined;

  get sender(): string | undefined {
    if (this._sender) return this._sender;
    if (this.web3.defaultAccount) return this.web3.defaultAccount;
    return undefined;
  }

  protected getSenderOrFail(): string {
    const sender = this.sender;
    if (!sender) {
      throw new Error("Sender is required");
    }
    return sender;
  }

  constructor({ address, web3, sender, gasEstimationMultiplayer }: IParams) {
    this._sender = sender;
    this.native = new web3.eth.Contract(Abi, address) as any;
    this.gasEstimationMultiplayer =
      gasEstimationMultiplayer ?? DEFAULT_GAS_ESTIMATION_MULTIPLAYER;
    this.web3 = web3;
  }

  protected async estimateGas<
    K,
    T extends PayableTransactionObject<K> | NonPayableTransactionObject<K>
  >(method: T, args?: Parameters<T["estimateGas"]>) {
    const originalEstimation = await method.estimateGas(...(args ?? []));
    return new BN(originalEstimation)
      .muln(this.gasEstimationMultiplayer)
      .toString();
  }

  async inSwapAndLiquify(): Promise<boolean> {
    return this.native.methods.inSwapAndLiquify().call();
  }

  async owner(): Promise<string> {
    return this.native.methods.owner().call();
  }

  async pool(): Promise<string> {
    return this.native.methods.pool().call();
  }

  async renounceOwnership(): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.renounceOwnership();
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async transferOwnership(
    newOwner: string
  ): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.transferOwnership(newOwner);
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async uniswapV2Router(): Promise<string> {
    return this.native.methods.uniswapV2Router().call();
  }

  async uniswapV2UsdcPair(): Promise<string> {
    return this.native.methods.uniswapV2UsdcPair().call();
  }

  async usdc(): Promise<string> {
    return this.native.methods.usdc().call();
  }

  async excludeAccountFromRewards(
    account: string
  ): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.excludeAccountFromRewards(account);
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async includeAccountForRewards(
    account: string
  ): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.includeAccountForRewards(account);
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async addToAmmList(account: string): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.addToAmmList(account);
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async removeFromAmmList(
    account: string
  ): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.removeFromAmmList(account);
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async changeWithdrawLimit(
    newLimit: number | string | BN
  ): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.changeWithdrawLimit(newLimit);
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async withdraw(
    recipient: string,
    amount: number | string | BN
  ): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.withdraw(recipient, amount);
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async setPoolAddress(pool_: string): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.setPoolAddress(pool_);
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async setSlippage(
    slippage: number | string | BN
  ): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.setSlippage(slippage);
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async transfer(
    recipient: string,
    amount: number | string | BN
  ): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.transfer(recipient, amount);
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async approve(
    spender: string,
    amount: number | string | BN
  ): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.approve(spender, amount);
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async transferFrom(
    sender: string,
    recipient: string,
    amount: number | string | BN
  ): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.transferFrom(sender, recipient, amount);
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async increaseAllowance(
    spender: string,
    addedValue: number | string | BN
  ): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.increaseAllowance(spender, addedValue);
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async decreaseAllowance(
    spender: string,
    subtractedValue: number | string | BN
  ): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.decreaseAllowance(
      spender,
      subtractedValue
    );
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async reflect(
    tAmount: number | string | BN
  ): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.reflect(tAmount);
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async name(): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.name();
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async symbol(): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.symbol();
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async decimals(): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.decimals();
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async totalSupply(): Promise<string> {
    return this.native.methods.totalSupply().call();
  }

  async balanceOf(account: string): Promise<string> {
    return this.native.methods.balanceOf(account).call();
  }

  async allowance(owner: string, spender: string): Promise<string> {
    return this.native.methods.allowance(owner, spender).call();
  }

  async isExcluded(account: string): Promise<boolean> {
    return this.native.methods.isExcluded(account).call();
  }

  async isAmmContract(account: string): Promise<boolean> {
    return this.native.methods.isAmmContract(account).call();
  }

  async totalFees(): Promise<string> {
    return this.native.methods.totalFees().call();
  }

  async getSlippage(): Promise<string> {
    return this.native.methods.getSlippage().call();
  }

  async getHoldingFee(): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.getHoldingFee();
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async getTreasureFee(): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.getTreasureFee();
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async reflectionFromToken(
    tAmount: number | string | BN,
    deductTransferFee: boolean
  ): Promise<string> {
    return this.native.methods
      .reflectionFromToken(tAmount, deductTransferFee)
      .call();
  }

  async tokenFromReflection(rAmount: number | string | BN): Promise<string> {
    return this.native.methods.tokenFromReflection(rAmount).call();
  }
}
