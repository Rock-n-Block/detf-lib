/* Generated by ts-generator ver. 0.0.8 */
/* tslint:disable */

import BN from "bn.js";
import { ContractOptions } from "web3-eth-contract";
import { EventLog } from "web3-core";
import { EventEmitter } from "events";
import {
  Callback,
  PayableTransactionObject,
  NonPayableTransactionObject,
  BlockType,
  ContractEventLog,
  BaseContract
} from "./types";

interface EventOptions {
  filter?: object;
  fromBlock?: BlockType;
  topics?: string[];
}

export type NewAdmin = ContractEventLog<{
  oldAdmin: string;
  newAdmin: string;
  0: string;
  1: string;
}>;
export type NewImplementation = ContractEventLog<{
  oldImplementation: string;
  newImplementation: string;
  0: string;
  1: string;
}>;
export type NewPendingAdmin = ContractEventLog<{
  oldPendingAdmin: string;
  newPendingAdmin: string;
  0: string;
  1: string;
}>;
export type ProposalCanceled = ContractEventLog<{
  id: string;
  0: string;
}>;
export type ProposalCreated = ContractEventLog<{
  id: string;
  proposer: string;
  targets: string[];
  values: string[];
  signatures: string[];
  calldatas: string[];
  startBlock: string;
  endBlock: string;
  description: string;
  0: string;
  1: string;
  2: string[];
  3: string[];
  4: string[];
  5: string[];
  6: string;
  7: string;
  8: string;
}>;
export type ProposalExecuted = ContractEventLog<{
  id: string;
  0: string;
}>;
export type ProposalQueued = ContractEventLog<{
  id: string;
  eta: string;
  0: string;
  1: string;
}>;
export type ProposalThresholdSet = ContractEventLog<{
  oldProposalThreshold: string;
  newProposalThreshold: string;
  0: string;
  1: string;
}>;
export type VoteCast = ContractEventLog<{
  voter: string;
  proposalId: string;
  support: string;
  votes: string;
  reason: string;
  0: string;
  1: string;
  2: string;
  3: string;
  4: string;
}>;
export type VotingDelaySet = ContractEventLog<{
  oldVotingDelay: string;
  newVotingDelay: string;
  0: string;
  1: string;
}>;
export type VotingPeriodSet = ContractEventLog<{
  oldVotingPeriod: string;
  newVotingPeriod: string;
  0: string;
  1: string;
}>;

export interface Governor extends BaseContract {
  constructor(
    jsonInterface: any[],
    address?: string,
    options?: ContractOptions
  ): Governor;
  clone(): Governor;
  methods: {
    /**
     * The EIP-712 typehash for the ballot struct used by the contract
     */
    BALLOT_TYPEHASH(): NonPayableTransactionObject<string>;

    /**
     * The EIP-712 typehash for the contract's domain
     */
    DOMAIN_TYPEHASH(): NonPayableTransactionObject<string>;

    /**
     * The maximum setable proposal threshold
     */
    MAX_PROPOSAL_THRESHOLD(): NonPayableTransactionObject<string>;

    /**
     * The max setable voting delay
     */
    MAX_VOTING_DELAY(): NonPayableTransactionObject<string>;

    /**
     * The max setable voting period
     */
    MAX_VOTING_PERIOD(): NonPayableTransactionObject<string>;

    /**
     * The minimum setable proposal threshold
     */
    MIN_PROPOSAL_THRESHOLD(): NonPayableTransactionObject<string>;

    /**
     * The min setable voting delay
     */
    MIN_VOTING_DELAY(): NonPayableTransactionObject<string>;

    /**
     * The minimum setable voting period
     */
    MIN_VOTING_PERIOD(): NonPayableTransactionObject<string>;

    /**
     * Administrator for this contract
     */
    admin(): NonPayableTransactionObject<string>;

    /**
     * The address of the DETF token
     */
    detf(): NonPayableTransactionObject<string>;

    /**
     * Active brains of Governor
     */
    implementation(): NonPayableTransactionObject<string>;

    /**
     * Initial proposal id set at become
     */
    initialProposalId(): NonPayableTransactionObject<string>;

    isInitiate(): NonPayableTransactionObject<boolean>;

    /**
     * The latest proposal for each proposer
     */
    latestProposalIds(arg0: string): NonPayableTransactionObject<string>;

    /**
     * The name of this contract
     */
    name(): NonPayableTransactionObject<string>;

    /**
     * Pending administrator for this contract
     */
    pendingAdmin(): NonPayableTransactionObject<string>;

    /**
     * The total number of proposals
     */
    proposalCount(): NonPayableTransactionObject<string>;

    /**
     * The maximum number of actions that can be included in a proposal
     */
    proposalMaxOperations(): NonPayableTransactionObject<string>;

    /**
     * The number of votes required in order for a voter to become a proposer
     */
    proposalThreshold(): NonPayableTransactionObject<string>;

    /**
     * The official record of all proposals ever proposed
     */
    proposals(
      arg0: number | string | BN
    ): NonPayableTransactionObject<{
      id: string;
      proposer: string;
      eta: string;
      startBlock: string;
      endBlock: string;
      forVotes: string;
      againstVotes: string;
      abstainVotes: string;
      canceled: boolean;
      executed: boolean;
      0: string;
      1: string;
      2: string;
      3: string;
      4: string;
      5: string;
      6: string;
      7: string;
      8: boolean;
      9: boolean;
    }>;

    /**
     * The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed
     */
    quorumVotes(): NonPayableTransactionObject<string>;

    /**
     * The address of the DETF Protocol Timelock
     */
    timelock(): NonPayableTransactionObject<string>;

    /**
     * The delay before voting on a proposal may take place, once proposed, in blocks
     */
    votingDelay(): NonPayableTransactionObject<string>;

    /**
     * The duration of voting on a proposal, in blocks
     */
    votingPeriod(): NonPayableTransactionObject<string>;

    /**
     * Used to initialize the contract during delegator contructor
     * @param detf_ The address of the DETF token
     * @param proposalThreshold_ The initial proposal threshold
     * @param timelock_ The address of the Timelock
     * @param votingDelay_ The initial voting delay
     * @param votingPeriod_ The initial voting period
     */
    initialize(
      timelock_: string,
      detf_: string,
      votingPeriod_: number | string | BN,
      votingDelay_: number | string | BN,
      proposalThreshold_: number | string | BN
    ): NonPayableTransactionObject<void>;

    /**
     * Admin only. Sets initial proposal id which initiates the contract, ensuring a continuous proposal id count
     * Initiate the Governor contract
     */
    initiate(): NonPayableTransactionObject<void>;

    /**
     * Function used to propose a new proposal. Sender must have delegates above the proposal threshold
     * @param calldatas Calldatas for proposal calls
     * @param description String description of the proposal
     * @param signatures Function signatures for proposal calls
     * @param targets Target addresses for proposal calls
     * @param values Eth values for proposal calls
     */
    propose(
      targets: string[],
      values: (number | string | BN)[],
      signatures: string[],
      calldatas: (string | number[])[],
      description: string
    ): NonPayableTransactionObject<string>;

    /**
     * Queues a proposal of state succeeded
     * @param proposalId The id of the proposal to queue
     */
    queue(proposalId: number | string | BN): NonPayableTransactionObject<void>;

    /**
     * Executes a queued proposal if eta has passed
     * @param proposalId The id of the proposal to execute
     */
    execute(proposalId: number | string | BN): PayableTransactionObject<void>;

    /**
     * Cancels a proposal only if sender is the proposer, or proposer delegates dropped below proposal threshold
     * @param proposalId The id of the proposal to cancel
     */
    cancel(proposalId: number | string | BN): NonPayableTransactionObject<void>;

    /**
     * Cast a vote for a proposal
     * @param proposalId The id of the proposal to vote on
     * @param support The support value for the vote. 0=against, 1=for, 2=abstain
     */
    castVote(
      proposalId: number | string | BN,
      support: number | string | BN
    ): NonPayableTransactionObject<void>;

    /**
     * Cast a vote for a proposal with a reason
     * @param proposalId The id of the proposal to vote on
     * @param reason The reason given for the vote by the voter
     * @param support The support value for the vote. 0=against, 1=for, 2=abstain
     */
    castVoteWithReason(
      proposalId: number | string | BN,
      support: number | string | BN,
      reason: string
    ): NonPayableTransactionObject<void>;

    /**
     * public function that accepts EIP-712 signatures for voting on proposals.
     * Cast a vote for a proposal by signature
     */
    castVoteBySig(
      proposalId: number | string | BN,
      support: number | string | BN,
      v: number | string | BN,
      r: string | number[],
      s: string | number[]
    ): NonPayableTransactionObject<void>;

    /**
     * Admin function for setting the voting delay
     * @param newVotingDelay new voting delay, in blocks
     */
    setVotingDelay(
      newVotingDelay: number | string | BN
    ): NonPayableTransactionObject<void>;

    /**
     * Admin function for setting the voting period
     * @param newVotingPeriod new voting period, in blocks
     */
    setVotingPeriod(
      newVotingPeriod: number | string | BN
    ): NonPayableTransactionObject<void>;

    /**
     * newProposalThreshold must be greater than the hardcoded min
     * Admin function for setting the proposal threshold
     * @param newProposalThreshold new proposal threshold
     */
    setProposalThreshold(
      newProposalThreshold: number | string | BN
    ): NonPayableTransactionObject<void>;

    /**
     * Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
     * Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
     * @param newPendingAdmin New pending admin.
     */
    setPendingAdmin(newPendingAdmin: string): NonPayableTransactionObject<void>;

    /**
     * Admin function for pending admin to accept role and update admin
     * Accepts transfer of admin rights. msg.sender must be pendingAdmin
     */
    acceptAdmin(): NonPayableTransactionObject<void>;

    getActions(
      proposalId: number | string | BN
    ): NonPayableTransactionObject<{
      targets: string[];
      values: string[];
      signatures: string[];
      calldatas: string[];
      0: string[];
      1: string[];
      2: string[];
      3: string[];
    }>;

    /**
     * Gets the receipt for a voter on a given proposal
     * @param proposalId the id of proposal
     * @param voter The address of the voter
     */
    getReceipt(
      proposalId: number | string | BN,
      voter: string
    ): NonPayableTransactionObject<[boolean, string, string]>;

    /**
     * Gets the state of a proposal
     * @param proposalId The id of the proposal
     */
    state(
      proposalId: number | string | BN
    ): NonPayableTransactionObject<string>;
  };
  events: {
    NewAdmin(cb?: Callback<NewAdmin>): EventEmitter;
    NewAdmin(options?: EventOptions, cb?: Callback<NewAdmin>): EventEmitter;

    NewImplementation(cb?: Callback<NewImplementation>): EventEmitter;
    NewImplementation(
      options?: EventOptions,
      cb?: Callback<NewImplementation>
    ): EventEmitter;

    NewPendingAdmin(cb?: Callback<NewPendingAdmin>): EventEmitter;
    NewPendingAdmin(
      options?: EventOptions,
      cb?: Callback<NewPendingAdmin>
    ): EventEmitter;

    ProposalCanceled(cb?: Callback<ProposalCanceled>): EventEmitter;
    ProposalCanceled(
      options?: EventOptions,
      cb?: Callback<ProposalCanceled>
    ): EventEmitter;

    ProposalCreated(cb?: Callback<ProposalCreated>): EventEmitter;
    ProposalCreated(
      options?: EventOptions,
      cb?: Callback<ProposalCreated>
    ): EventEmitter;

    ProposalExecuted(cb?: Callback<ProposalExecuted>): EventEmitter;
    ProposalExecuted(
      options?: EventOptions,
      cb?: Callback<ProposalExecuted>
    ): EventEmitter;

    ProposalQueued(cb?: Callback<ProposalQueued>): EventEmitter;
    ProposalQueued(
      options?: EventOptions,
      cb?: Callback<ProposalQueued>
    ): EventEmitter;

    ProposalThresholdSet(cb?: Callback<ProposalThresholdSet>): EventEmitter;
    ProposalThresholdSet(
      options?: EventOptions,
      cb?: Callback<ProposalThresholdSet>
    ): EventEmitter;

    VoteCast(cb?: Callback<VoteCast>): EventEmitter;
    VoteCast(options?: EventOptions, cb?: Callback<VoteCast>): EventEmitter;

    VotingDelaySet(cb?: Callback<VotingDelaySet>): EventEmitter;
    VotingDelaySet(
      options?: EventOptions,
      cb?: Callback<VotingDelaySet>
    ): EventEmitter;

    VotingPeriodSet(cb?: Callback<VotingPeriodSet>): EventEmitter;
    VotingPeriodSet(
      options?: EventOptions,
      cb?: Callback<VotingPeriodSet>
    ): EventEmitter;

    allEvents(options?: EventOptions, cb?: Callback<EventLog>): EventEmitter;
  };

  once(event: "NewAdmin", cb: Callback<NewAdmin>): void;
  once(event: "NewAdmin", options: EventOptions, cb: Callback<NewAdmin>): void;

  once(event: "NewImplementation", cb: Callback<NewImplementation>): void;
  once(
    event: "NewImplementation",
    options: EventOptions,
    cb: Callback<NewImplementation>
  ): void;

  once(event: "NewPendingAdmin", cb: Callback<NewPendingAdmin>): void;
  once(
    event: "NewPendingAdmin",
    options: EventOptions,
    cb: Callback<NewPendingAdmin>
  ): void;

  once(event: "ProposalCanceled", cb: Callback<ProposalCanceled>): void;
  once(
    event: "ProposalCanceled",
    options: EventOptions,
    cb: Callback<ProposalCanceled>
  ): void;

  once(event: "ProposalCreated", cb: Callback<ProposalCreated>): void;
  once(
    event: "ProposalCreated",
    options: EventOptions,
    cb: Callback<ProposalCreated>
  ): void;

  once(event: "ProposalExecuted", cb: Callback<ProposalExecuted>): void;
  once(
    event: "ProposalExecuted",
    options: EventOptions,
    cb: Callback<ProposalExecuted>
  ): void;

  once(event: "ProposalQueued", cb: Callback<ProposalQueued>): void;
  once(
    event: "ProposalQueued",
    options: EventOptions,
    cb: Callback<ProposalQueued>
  ): void;

  once(event: "ProposalThresholdSet", cb: Callback<ProposalThresholdSet>): void;
  once(
    event: "ProposalThresholdSet",
    options: EventOptions,
    cb: Callback<ProposalThresholdSet>
  ): void;

  once(event: "VoteCast", cb: Callback<VoteCast>): void;
  once(event: "VoteCast", options: EventOptions, cb: Callback<VoteCast>): void;

  once(event: "VotingDelaySet", cb: Callback<VotingDelaySet>): void;
  once(
    event: "VotingDelaySet",
    options: EventOptions,
    cb: Callback<VotingDelaySet>
  ): void;

  once(event: "VotingPeriodSet", cb: Callback<VotingPeriodSet>): void;
  once(
    event: "VotingPeriodSet",
    options: EventOptions,
    cb: Callback<VotingPeriodSet>
  ): void;
}
