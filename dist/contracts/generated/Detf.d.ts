import BN from "bn.js";
import Web3 from "web3";
import { PromiEvent, TransactionReceipt } from "web3-core/types";
import { Detf as Web3Contract } from "./Detf.web3";
import { PayableTransactionObject, NonPayableTransactionObject } from "./types";
interface IParams {
    address: string;
    web3: Web3;
    sender?: string;
    gasEstimationMultiplayer?: number;
}
export declare class Detf {
    native: Web3Contract;
    gasEstimationMultiplayer: number;
    web3: Web3;
    _sender: string | undefined;
    get sender(): string | undefined;
    protected getSenderOrFail(): string;
    constructor({ address, web3, sender, gasEstimationMultiplayer }: IParams);
    protected estimateGas<K, T extends PayableTransactionObject<K> | NonPayableTransactionObject<K>>(method: T, args?: Parameters<T["estimateGas"]>): Promise<string>;
    DELEGATION_TYPEHASH(): Promise<string>;
    DOMAIN_TYPEHASH(): Promise<string>;
    addToAmmList(account: string): Promise<PromiEvent<TransactionReceipt>>;
    allowance(owner: string, spender: string): Promise<string>;
    approve(spender: string, amount: number | string | BN): Promise<PromiEvent<TransactionReceipt>>;
    balanceOf(account: string): Promise<string>;
    changeWithdrawLimit(newLimit: number | string | BN): Promise<PromiEvent<TransactionReceipt>>;
    checkpoints(arg0: string, arg1: number | string | BN): Promise<{
        fromBlock: string;
        votes: string;
        0: string;
        1: string;
    }>;
    decreaseAllowance(spender: string, subtractedValue: number | string | BN): Promise<PromiEvent<TransactionReceipt>>;
    delegates(arg0: string): Promise<string>;
    delegatorVotes(arg0: string): Promise<string>;
    excludeAccountFromRewards(account: string): Promise<PromiEvent<TransactionReceipt>>;
    getHoldingFee(): Promise<PromiEvent<TransactionReceipt>>;
    getSlippage(): Promise<string>;
    getTreasureFee(): Promise<PromiEvent<TransactionReceipt>>;
    inSwapAndLiquify(): Promise<boolean>;
    includeAccountForRewards(account: string): Promise<PromiEvent<TransactionReceipt>>;
    increaseAllowance(spender: string, addedValue: number | string | BN): Promise<PromiEvent<TransactionReceipt>>;
    isAmmContract(account: string): Promise<boolean>;
    isExcluded(account: string): Promise<boolean>;
    name(): Promise<PromiEvent<TransactionReceipt>>;
    nonces(arg0: string): Promise<string>;
    numCheckpoints(arg0: string): Promise<string>;
    owner(): Promise<string>;
    pool(): Promise<string>;
    reflect(tAmount: number | string | BN): Promise<PromiEvent<TransactionReceipt>>;
    reflectionFromToken(tAmount: number | string | BN, deductTransferFee: boolean): Promise<string>;
    removeFromAmmList(account: string): Promise<PromiEvent<TransactionReceipt>>;
    renounceOwnership(): Promise<PromiEvent<TransactionReceipt>>;
    setPoolAddress(pool_: string): Promise<PromiEvent<TransactionReceipt>>;
    setSlippage(slippage: number | string | BN): Promise<PromiEvent<TransactionReceipt>>;
    symbol(): Promise<PromiEvent<TransactionReceipt>>;
    tokenFromReflection(rAmount: number | string | BN): Promise<string>;
    totalFees(): Promise<string>;
    totalSupply(): Promise<string>;
    transfer(recipient: string, amount: number | string | BN): Promise<PromiEvent<TransactionReceipt>>;
    transferFrom(sender: string, recipient: string, amount: number | string | BN): Promise<PromiEvent<TransactionReceipt>>;
    transferOwnership(newOwner: string): Promise<PromiEvent<TransactionReceipt>>;
    uniswapV2Router(): Promise<string>;
    uniswapV2UsdcPair(): Promise<string>;
    usdc(): Promise<string>;
    withdraw(recipient: string, amount: number | string | BN): Promise<PromiEvent<TransactionReceipt>>;
    delegate(delegatee: string): Promise<PromiEvent<TransactionReceipt>>;
    delegateBySig(delegatee: string, nonce: number | string | BN, expiry: number | string | BN, v: number | string | BN, r: string | number[], s: string | number[]): Promise<PromiEvent<TransactionReceipt>>;
    getCurrentVotes(account: string): Promise<string>;
    getPriorVotes(account: string, blockNumber: number | string | BN): Promise<string>;
}
export {};
